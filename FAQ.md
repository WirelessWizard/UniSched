# Взаимодействие с объектами

Q: Как создать объект?

A: Достаточно вызвать фабричный метод create класса Core::AbstractUI. Этот
метод находится в protected секции, поэтому вызываться должен из класса,
реализующего пользовательский интерфейс. Примеры:

    Object * John = create<Person>();
    Object * Party = create<Event>();
    Object * Scorpions = create<Group>();


Q: Почему все созданные объекты имеют тип 'Object *'?

A: Можно указать и точное имя объекта, однако это ничего не изменит. Все
методы, необходимые для работы объявлены и реализованы в классе Object.


Q: Я создал объект, что мне теперь делать?

A: Теперь можно его изменять. Для простоты реализации все объекты создаются
пустыми. С помощью метода update(name, value) можно установить значение любого
поля объекта. Будьте осторожны, если полю уже установлено значение одного типа,
а вы попробуете ему присвоить значение другого типа, произойдет исключительная
ситуация boost::bad_any_cast.

Q: Я еще не назначал полю %fieldname% значение, почему я получил исключение?

A: У каждого типа объектов есть поля, которые должны иметь стого определенный
тип, а некоторые, вдобавок, и ограниченый диапозон значений. Чтобы не путаться
вот полный список.

    +---------------+-------------+---------------------+
    | Имя поля      | Тип поля    | Допустимые значения |
    +===============+=============+=====================+
    | Person                                            |
    +---------------+-------------+---------------------+
    | name          | std::string | Любые               |
    +---------------+-------------+---------------------+
    | surname       | std::string | Любые               |
    +---------------+-------------+---------------------+
    | birthday      | time_t      | Любые               |
    +---------------+-------------+---------------------+
    | sex           | std::string | "MALE", "FEMALE"    |
    +---------------+-------------+---------------------+
    | groups        | -           | -                   |
    +===============+=============+=====================+
    | Group                                             |
    +---------------+-------------+---------------------+
    | name          | std::string | Любые               |
    +---------------+-------------+---------------------+
    | people        | -           | -                   |
    +---------------+-------------+---------------------+
    | parent_groups | -           | -                   |
    +---------------+-------------+---------------------+
    | child_groups  | -           | -                   |
    +===============+=============+=====================+
    | Event                                             |
    +---------------+-------------+---------------------+
    | name          | std::string | Любые               |
    +---------------+-------------+---------------------+
    | begin         | time_t      | Любые               |
    +---------------+-------------+---------------------+
    | duration      | time_t      | Любые               |
    +---------------+-------------+---------------------+
    | people        | -           | -                   |
    +---------------+-------------+---------------------+
    | child_groups  | -           | -                   |
    +---------------+-------------+---------------------+


Q: Почему у половины полей в таблице не указаны тип и допустимые значения?

A: Эти поля нельзя изменить с помощью метода update. Их тип:
std::vector<Object *>. Они хранят связи с другими объектами. В данную таблицу
они занесены, чтобы обозначить, что эти поля заняты.

Q: Как сохранить данные созданных объектов на диск?

A: Полное резервное копирование данных производится методом AbstractUI::dump(std::string).
Аргументом является имя файла, в котором будут храниться данные всех созданных объектов
(в формате языка YAML). Формат генирируемого файла следующий:
  +-----------------------------------+
  | - Object: [Person/Group/Event]    |
  |   ID: 7890                        |
  |   VCard:                          |
  |     name: William                 |
  |     surname: Gates                |
  |     sex: MALE                     |
  | - Object: ... # etc.              |
  +-----------------------------------+
При использования метода dump() происходит создание нового файла, если с файл с тем же
именем уже существует, то он будет перезаписан.
    С другой стороны, для загрузки информации об объектах их файла используется
метод AbstractUI::load(std::string). В качестве аргемента -- имя файла с
данными объектов на языке YAML. Метод возвращает bool в зависимости от того,
успешно ли прошел парсинг.
    Пример использования можно найти в src/module/dummy.cpp (пример основан на файле
fixtures/database.yaml).

Q: Как я могу менять связи между объектами?

A: С помощью методов connect и disconnect можно связывать и отвязывать
объекты. Например:

    Freddy->connect(Queen);
    Beatles->connect(John);

    ITMonsters->connect(apple);

    Party->connect(John);
    Paul->connect(Party);
    Party->connect(Girls);


Q: Я хочу связать две группы, метод connect какой из них мне необходимо
вызвать?

A: Требуется вызвать метод той группы, в которую включается более мелкая
группа. Так, в предыдущем примере в группу ITMonsters включается группа apple.


Q: Все прекрасно, но как мне просмотреть поля объектов?

A: Достаточно вызвать метод read(name), чтобы получить значение поля. Учтите,
что все поля хранятся в виде boost::any, поэтому они требуют
преобразования.  Например:

    Object *John = create<Person>();
    John.update("name", std::string("John");

    std::cout << boost::any_cast<const std::string>(John.read("name"))
        << std::endl;

Вывод:
    
    John


Q: А можно как-то получить все поля объекта сразу, или список их имен?

A: Для этого служит метод read() он возвращает коллекцию полей
const std::map<const std::string, boost::any>


Q: А как получить список связей?

A: Тем же методом read(name) - значение, которое он возвратит можно привести к
типу const std::vector<Object *>.


Q: Хорошо, я все понял, кроме одного, как удалить объект?

A: Для этого служит метод remove(object) класса AbstractUI.


Q: Ой... а есть способ хранить объекты как-то поудобнее?

A: Конечно. Во первых все объекты хранятся внутри AbstractUI класса, благодаря
этому можно искать объекты по их полям. А также есть кэш объектов. В него
попадают все результаты поиска и все объекты, созданные пользователем.


Q: Кэш? А что он из себя представляет и как его использовать?

A: Кэш это коллекция объектов, типа std::vector<Object *>, вы можете делать с
ним все что захотите, чтобы получить объект кэша вызовите метод cache() класса
AbstractUI.


Q: В кэше скопилось много ненужного, есть способ его очистить?

A: Конечно, метод reset_cache() предназначен именно для этого.


Q: А как воспользоваться поиском?

A: Поиск осуществляется методом search(parameters), в качестве аргумента ему
нужно передать const std::map<std::string, boost::any>, содержащий пары имя
поля - значение. В кэш добавятся все объекты, сожержащие все указанные поля с
указанными значениями. Если вызвать поиск без параметров методом search(),
будут возвращены все объекты.


Q: Это всё? а у меня еще полно вопросов!

A: На этом у меня фантазия кончилась. Если после всего выше прочитанного еще
остались вопросы, значит вы можете убиться об стенку или изучать код.

